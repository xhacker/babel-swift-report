\documentclass{sfuthesis}

\title{Babel Swift: An Objective-C to Swift Conversion Tool}
\thesistype{Dissertation}
\author{Dongyuan Liu}
\degree{Bachelor of Science}
\discipline{Computing Science}
\department{School of Computing Science}
\faculty{Faculty of Applied Science}
\copyrightyear{2016}
\semester{Spring 2016}
%\date{1 April 2016}
\copyrightnotice{This work is licensed under the Creative Commons
Attribution-NonCommercial-ShareAlike 4.0 International
(\url{http://creativecommons.org/licenses/by-nc-sa/4.0/})}

\keywords{Objective-C, Swift, Source Code Transformation}

%\committee{%
%	\chair{Pamela Isely}{Professor}
%	\member{Emmett Brown}{Senior Supervisor\\Professor}
%	\member{Bonnibel Bubblegum}{Supervisor\\Associate Professor}
%	\member{James Moriarty}{Supervisor\\Adjunct Professor}
%	\member{Kaylee Frye}{Internal Examiner\\Assistant Professor\\School of Engineering Science}
%	\member{Hubert J.\ Farnsworth}{External Examiner\\Professor\\Department of Quantum Fields\\Mars University}
%}

%   PACKAGES AND CUSTOMIZATIONS  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Add any packages or custom commands you need for your thesis here.
%   You don't need to call the following packages, which are already called in
%   the sfuthesis class file:
%
%   - appendix
%   - etoolbox
%   - fontenc
%   - geometry
%   - lmodern
%   - nowidow
%   - setspace
%   - tocloft
%
%   If you call one of the above packages (or one of their dependencies) with
%   options, you may get a "Option clash" LaTeX error. If you get this error,
%   you can fix it by removing your copy of \usepackage and passing the options
%   you need by adding
%
%       \PassOptionsToPackage{<options>}{<package>}
%
%   before \documentclass{sfuthesis}.
%

\usepackage{amsmath,amssymb,amsthm}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{listings}






%   FRONTMATTER  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Title page, committee page, copyright declaration, abstract,
%   dedication, acknowledgements, table of contents, etc.
%

\begin{document}

\frontmatter
\maketitle{}
\makecommittee{}

\begin{abstract}
Swift is a new programming language developed by Apple, designed to replace Objective-C as the main programming language on Apple platforms. This paper introduces Babel Swift, a new conversion tool for converting Objective-C code to Swift. Our tool focuses on converting code snippets, including functions, code blocks, and statements. The most important feature of Babel Swift is the ability to convert incomplete code snippets with undefined identifiers. Furthermore, Babel Swift could generate Swift-only syntax. At last, we evaluate Babel Swift by comparing with other existing tools.
\end{abstract}


\begin{dedication} % optional
\end{dedication}


\begin{acknowledgements} % optional
\end{acknowledgements}

\addtoToC{Table of Contents}\tableofcontents\clearpage
\addtoToC{List of Tables}\listoftables\clearpage
\addtoToC{List of Figures}\listoffigures





%   MAIN MATTER  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Start writing your thesis --- or start \include ing chapters --- here.
%

\mainmatter%

\chapter{Introduction}

\section{Objective-C and Swift}

Objective-C is an object-oriented programming language. It's the main programming language used by Apple on its OS X and iOS platforms. In 2014, Apple introduced the new Swift language, which is being designed to replace Objective-C for building iOS and OS X apps.

\section{Existing Objective-C to Swift Conversion Tools}

Considering there are a lot of Objective-C code on Apple platforms, there is a high demand for Objective-C to Swift conversion tools. objc2swift \cite{objc2swift} is an open-source conversion tool. Swiftify \cite{swiftify} and iSwift \cite{iswift} are two commercial conversion tools.

These conversion tools are all designed for transform complete code or complete projects. They cannot handle incomplete code snippets with undefined identifiers. However, converting incomplete code snippets is a typical use case of conversion tools. For example, a programmer may find an Objective-C code snippet on Stackoverflow, and wants to use it in a Swift project.

\section{Introducing Babel Swift}

This paper introduces Babel Swift, a new conversion tool for converting Objective-C code to Swift. Babel Swift was designed for handling incomplete code snippets. It could also generate Swift-specific code, e.g., it has the ability to convert C-style \texttt{for} loops to \texttt{for-in} statements and \texttt{stride} in Swift. Babel Swift is written in Python, based on libclang \cite{libclang}.

% TODO: other features?

\chapter{Objectives and Implementation}

Babel Swift is an Objective-C to Swift code conversion tool. It has two main objectives -- converting incomplete code snippets, and generating Swift-specific code.

\section{Overall Design}

Babel Swift is written in Python, based on libclang \cite{libclang} and its Python binding. libclang is a C interface to Clang \cite{clang}, which is a C language family frontend for LLVM. libclang provides a small API for parsing source code and accessing the parsed abstract syntax tree (AST). By using Clang as the parser, we can focus on improving the conversion.

In libclang, a \emph{cursor} represent a location within the AST. Our transform function takes a cursor as input, and outputs the converted Swift code. For each cursor, the transform function traverses all the children and transform them recursively.

\section{Handling Code Snippets}

In this paper, we use the term \emph{code snippet} to represent a piece of code \emph{within} a function. A code snippet consists of one or more statements. An example of Objective-C \emph{code snippet} would be (\texttt{NSPopover} is a class in \emph{AppKit}, a foundational framework used in Mac development):

\lstset{language=[Objective]C, caption={A code snippet}, breaklines=true}
\begin{lstlisting}[frame=single]
NSInteger answer = 42;
if (answer == 42) {
    NSPopover *popover = [[NSPopover alloc] init];
    [popover run];
}
\end{lstlisting}

Although it seems to be easy to handle code snippets, libclang refuses to parse them. For Objective-C, libclang expects the input to be a complete source file. To overcome this limitation, Babel Swift wraps the input code snippet into a complete source file. In the example above, the wrapped input for libclang is:

\lstset{language=[Objective]C, caption={A complete source file containing the snippet}, breaklines=true}
\begin{lstlisting}[frame=single]
#import <AppKit/AppKit.h>
#import "BabelSwiftHeader.h"

@implementation __BABEL_SWIFT_WRAPPER_CLASS__

- (id)__BABEL_SWIFT_WRAPPER_METHOD__ {

NSInteger answer = 42;
if (answer == 42) {
    NSPopover *popover = [[NSPopover alloc] init];
    [popover run];
}

}

@end
\end{lstlisting}

We use a special class name \texttt{\_\_BABEL\_SWIFT\_WRAPPER\_CLASS\_\_} and a special method name \texttt{\_\_BABEL\_SWIFT\_WRAPPER\_METHOD\_\_} to wrap the snippet. We also import two headers. \texttt{AppKit/AppKit.h} contains many fundamental declarations in Cocoa, e.g. \texttt{NSInteger} and \texttt{NSDictionary}. \texttt{BabelSwiftHeader.h} is for handling \emph{incomplete code snippets}, which will be elaborated in the next section.

% TODO: show AST and how to convert them

\section{Handling Incomplete Code Snippets}

We define an \emph{incomplete code snippet} as a code snippet which contains undefined identifiers. For example, the following Objective-C code snippet is an \emph{incomplete code snippet}, because both \texttt{speed} and \texttt{TimeMachine} are undefined identifiers.

\lstset{language=[Objective]C, caption={An incomplete code snippet\label{lst:incomplete}}, breaklines=true}
\begin{lstlisting}[frame=single]
if (speed == 88) {
    TimeMachine *timeMachine = [[TimeMachine alloc] init];
    [timeMachine run];
}
\end{lstlisting}

libclang cannot parse incomplete code snippets because it doesn't know whether an identifier is a variable name or a class name. For the above snippet, libclang generated the following error message:

\lstset{caption={Error messages generated by libclang for listing \ref{lst:incomplete}}, breaklines=true}
\begin{lstlisting}[frame=single]
input.m:7:5: error: use of undeclared identifier 'speed'
input.m:8:5: error: use of undeclared identifier 'TimeMachine'
input.m:8:18: error: use of undeclared identifier 'timeMachine'
input.m:8:34: error: use of undeclared identifier 'TimeMachine'
input.m:9:6: error: use of undeclared identifier 'timeMachine'
\end{lstlisting}

We use a loop to fix them one by one until there's no errors. For each error, we use the identifier to guess whether it's a class name or a variable name. If the identifier starts with a capital letter, we assume it's a class name, otherwise we assume it's a variable name.
% TODO: this implementation will be changed to support property access
As mentioned before, we included a special header file \texttt{BabelSwiftHeader.h}. For undefined variable names, we declare them in the header file with type \texttt{id}. \texttt{id} in Objective-C is similar to \texttt{void *} in C, represents a pointer to any type. For undefined class names, we add interfaces in the header file. It is obvious to see that we may make wrong guess based on this approach, e.g. a programmer could name a variable \texttt{IPAddress}. To make sure all the identifiers are being declared correctly, if it failed to fix the error, we will make another opposite guess. After fixing all the errors, libclang would be able to generate the AST. The header file \texttt{BabelSwiftHeader.h} would be like:

\lstset{language=[Objective]C, caption={The content of \texttt{BabelSwiftHeader.h} after fixing all the errors}, breaklines=true}
\begin{lstlisting}[frame=single]
#define BABEL_SWIFT_SOME_TYPE id

@class __BABEL_SWIFT_WRAPPER_CLASS__;
@class TimeMachine;

@interface __BABEL_SWIFT_WRAPPER_CLASS__ : NSObject
@end

@interface TimeMachine : NSObject
@end

BABEL_SWIFT_SOME_TYPE speed;
\end{lstlisting}

% TODO: chained property access

\section{Generating Swift-specific Code}

Swift have a different set of data types than Objective-C. We use mappings to convert basic data types. Because it's allowed to use C types in Objective-C, we also have mappings to C types.

\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf Objective-C \cite{objcdatatypes}} & {\bf Swift \cite{swiftdatatypes}} & \specialcell{{\bf Size in 32/64-bit}\\{\bf runtime (bytes)}} \\
\hline
char       & Int8   & 1 / 1 \\
BOOL, bool & Int8   & 1 / 1 \\
short      & Int16  & 2 / 2 \\
int        & Int32  & 4 / 4 \\
long       & Int    & 4 / 8 \\
long long  & Int64  & 8 / 8 \\
size\_t    & Int    & 4 / 8 \\
time\_t    & Int    & 4 / 8 \\
NSInteger  & Int    & 4 / 8 \\
NSUInteger & Int    & 4 / 8 \\
float      & Float  & 4 / 4 \\
double     & Double & 8 / 8 \\
\hline
\end{tabular}
\end{center}
\caption{Mappings for basic data types}
\end{table}

method renaming

for loop

others (++, selector)

\section{Improving libclang}

Although libclang provides a set of methods for accessing the AST, it's implementation is incomplete.

unexposed

information in cursor

% TODO: Using PCH for better performance

\section{Remaining Issues}

comments

type inference

macros

\chapter{Evaluation}

\chapter{Alternative Designs}

\chapter{Conclusion}



%   BACK MATTER  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   References and appendices. Appendices come after the bibliography and
%   should be in the order that they are referred to in the text.
%
%   If you include figures, etc. in an appendix, be sure to use
%
%       \caption[]{...}
%
%   to make sure they are not listed in the List of Figures.
%

\backmatter%
	\addtoToC{Bibliography}
	\bibliographystyle{plain}
	\bibliography{references}

\begin{appendices} % optional
	\chapter{Code}
\end{appendices}
\end{document}

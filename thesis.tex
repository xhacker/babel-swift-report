\documentclass{sfuthesis}

\title{Babel Swift: An Objective-C to Swift Conversion Tool}
\thesistype{Dissertation}
\author{Dongyuan Liu}
\degree{Bachelor of Science}
\discipline{Computing Science}
\department{School of Computing Science}
\faculty{Faculty of Applied Science}
\copyrightyear{2016}
\semester{Spring 2016}
%\date{1 April 2016}
\copyrightnotice{This work is licensed under the Creative Commons
Attribution-NonCommercial-ShareAlike 4.0 International
(\url{http://creativecommons.org/licenses/by-nc-sa/4.0/})}

\keywords{Objective-C, Swift, Source Code Transformation}

%\committee{%
%	\chair{Pamela Isely}{Professor}
%	\member{Emmett Brown}{Senior Supervisor\\Professor}
%	\member{Bonnibel Bubblegum}{Supervisor\\Associate Professor}
%	\member{James Moriarty}{Supervisor\\Adjunct Professor}
%	\member{Kaylee Frye}{Internal Examiner\\Assistant Professor\\School of Engineering Science}
%	\member{Hubert J.\ Farnsworth}{External Examiner\\Professor\\Department of Quantum Fields\\Mars University}
%}

%   PACKAGES AND CUSTOMIZATIONS  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Add any packages or custom commands you need for your thesis here.
%   You don't need to call the following packages, which are already called in
%   the sfuthesis class file:
%
%   - appendix
%   - etoolbox
%   - fontenc
%   - geometry
%   - lmodern
%   - nowidow
%   - setspace
%   - tocloft
%
%   If you call one of the above packages (or one of their dependencies) with
%   options, you may get a "Option clash" LaTeX error. If you get this error,
%   you can fix it by removing your copy of \usepackage and passing the options
%   you need by adding
%
%       \PassOptionsToPackage{<options>}{<package>}
%
%   before \documentclass{sfuthesis}.
%

\usepackage{amsmath,amssymb,amsthm}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[cache=false,outputdir=.texpadtmp]{minted}






%   FRONTMATTER  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Title page, committee page, copyright declaration, abstract,
%   dedication, acknowledgements, table of contents, etc.
%

\begin{document}

\frontmatter
\maketitle{}
\makecommittee{}

\begin{abstract}
Swift is a new programming language developed by Apple, designed to replace Objective-C as the main programming language on Apple platforms. This thesis introduces Babel Swift, a new conversion tool for converting Objective-C code to Swift. Our tool focuses on converting code snippets. The most important feature of Babel Swift is the ability to convert incomplete code snippets with undefined identifiers. Furthermore, Babel Swift could generate Swift-only syntax. In the thesis, we describes the design and implementation of Babel Swift. We also evaluate Babel Swift by comparing with other existing tools.
\end{abstract}


\begin{dedication} % optional
\end{dedication}


\begin{acknowledgements} % optional
\end{acknowledgements}

\addtoToC{Table of Contents}\tableofcontents\clearpage
\addtoToC{List of Tables}\listoftables\clearpage
\addtoToC{List of Figures}\listoffigures\clearpage
\addtoToC{List of Listings}\listoflistings





%   MAIN MATTER  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Start writing your thesis --- or start \include ing chapters --- here.
%

\mainmatter%

\chapter{Introduction}

\section{Objective-C and Swift}

Objective-C is an object-oriented programming language. It's the main programming language used by Apple on its OS X and iOS platforms. In 2014, Apple introduced the new Swift language, which is being designed to replace Objective-C for building iOS and OS X apps.

\section{Objective-C to Swift Conversion Tools}

Considering there are a lot of Objective-C code on Apple platforms, there is a high demand for Objective-C to Swift conversion tools. There are some existing conversion tools objc2swift \cite{objc2swift} is an open-source conversion tool. Swiftify \cite{swiftify} and iSwift \cite{iswift} are two commercial conversion tools.

The limitation of the existing conversion tools is that they are all designed for transform complete code or complete projects. They cannot handle incomplete code snippets with undefined identifiers. However, converting incomplete code snippets is a typical use case of conversion tools. For example, a programmer may find an Objective-C code snippet on Stackoverflow, and wants to use it in a Swift project.

\section{Introducing Babel Swift}

This thesis introduces Babel Swift, a new conversion tool for converting Objective-C code to Swift. Babel Swift was designed for handling incomplete code snippets. It could also generate Swift-specific code, e.g., it has the ability to convert C-style \texttt{for} loops to \texttt{for-in} statements and \texttt{stride} in Swift. Babel Swift is written in Python, based on libclang \cite{libclang}. The full source code could be found on GitHub \cite{babelswift}.

% TODO: other features?

\chapter{Objectives and Implementation}

Babel Swift is an Objective-C to Swift code conversion tool. It has two main objectives -- converting incomplete code snippets, and generating Swift-specific code.

\section{Overall Design}

Babel Swift is written in Python, based on libclang \cite{libclang} and its Python binding. libclang is a C interface to Clang \cite{clang}, which is a C language family frontend for LLVM. libclang provides a small API for parsing source code and accessing the parsed abstract syntax tree (AST). By using Clang as the parser, we can focus on improving the conversion.

In libclang, a \emph{cursor} represent a location within the AST. Our transform function takes a cursor as input, and outputs the converted Swift code. For each cursor, the transform function traverses all the children and transform them recursively.

\section{Handling Code Snippets}

In this paper, we use the term \emph{code snippet} to represent a piece of code \emph{within} a function. A code snippet consists of one or more statements. An example of Objective-C \emph{code snippet} would be (\texttt{NSPopover} is a class in \emph{AppKit}, a foundational framework used in Mac development):

\begin{listing}
\caption{A code snippet}
\begin{minted}{objc}
NSInteger answer = 42;
if (answer == 42) {
    NSPopover *popover = [[NSPopover alloc] init];
    [popover run];
}
\end{minted}
\end{listing}

Although it seems to be easy to handle code snippets, libclang refuses to parse them. For Objective-C, libclang expects the input to be a complete source file. To overcome this limitation, Babel Swift wraps the input code snippet into a complete source file. In the example above, the wrapped input for libclang is:

\begin{listing}
\caption{A complete source file containing the snippet}	
\label{lst:snippet}
\begin{minted}{objc}
#import <AppKit/AppKit.h>
#import "BabelSwiftHeader.h"

@implementation __BABEL_SWIFT_WRAPPER_CLASS__

- (id)__BABEL_SWIFT_WRAPPER_METHOD__ {

NSInteger answer = 42;
if (answer == 42) {
    NSPopover *popover = [[NSPopover alloc] init];
    [popover run];
}

}

@end
\end{minted}
\end{listing}

We use a special class name \texttt{\_\_BABEL\_SWIFT\_WRAPPER\_CLASS\_\_} and a special method name \texttt{\_\_BABEL\_SWIFT\_WRAPPER\_METHOD\_\_} to wrap the snippet. We also import two headers. \texttt{AppKit/AppKit.h} contains many fundamental declarations in Cocoa, e.g. \texttt{NSInteger} and \texttt{NSDictionary}. \texttt{BabelSwiftHeader.h} is for handling \emph{incomplete code snippets}, which will be elaborated in the next section.

After wrapping the snippet into a complete file, we use libclang to parse the file and generate the AST. In libclang, each node in the AST is a \emph{cursor}. Our transform function takes a cursor as input, and outputs the converted Swift code. For each cursor, the transform function traverses all the children and transform them recursively. We use different strategies for different cursor types when concatenating the Swift results for the children. For example, for \texttt{COMPOUND\_STMT} cursor, we simply convert all its children and concat them together; For \texttt{IF\_STMT} cursor, we convert its conditional statement and its body, and generate Swift \texttt{if} statement as \texttt{if \emph{condition} \{ \emph{body} \}}.

\begin{listing}[H]
\caption{The AST generated by libclang for listing \ref{lst:snippet}}
\begin{verbatim}
 (CursorKind.COMPOUND_STMT)
  +-- (CursorKind.DECL_STMT)
  |  +--answer (CursorKind.VAR_DECL)
  |     +--NSInteger (CursorKind.TYPE_REF)
  |     +-- (CursorKind.IMPLICIT_CAST_EXPR_STMT)
  |        +-- (CursorKind.INTEGER_LITERAL)
  +-- (CursorKind.IF_STMT)
     +--== (CursorKind.BINARY_OPERATOR)
     |  +-- (CursorKind.IMPLICIT_CAST_EXPR_STMT)
     |  |  +--answer (CursorKind.DECL_REF_EXPR)
     |  +-- (CursorKind.IMPLICIT_CAST_EXPR_STMT)
     |     +-- (CursorKind.INTEGER_LITERAL)
     +-- (CursorKind.COMPOUND_STMT)
        +-- (CursorKind.DECL_STMT)
        |  +--popover (CursorKind.VAR_DECL)
        |     +--NSPopover (CursorKind.OBJC_CLASS_REF)
        |     +--init (CursorKind.OBJC_MESSAGE_EXPR)
        |        +--alloc (CursorKind.OBJC_MESSAGE_EXPR)
        |           +--NSPopover (CursorKind.OBJC_CLASS_REF)
        +--run (CursorKind.OBJC_MESSAGE_EXPR)
           +-- (CursorKind.IMPLICIT_CAST_EXPR_STMT)
              +--popover (CursorKind.DECL_REF_EXPR)
\end{verbatim}
\end{listing}

% TODO: show AST and how to convert them

\section{Handling Incomplete Code Snippets}

We define an \emph{incomplete code snippet} as a code snippet which contains undefined identifiers. For example, the following Objective-C code snippet is an \emph{incomplete code snippet}, because both \texttt{speed} and \texttt{TimeMachine} are undefined identifiers.

\begin{listing}
\caption{An incomplete code snippet}
\label{lst:incomplete}
\begin{minted}{objc}
if (speed == 88) {
    TimeMachine *timeMachine = [[TimeMachine alloc] init];
    [timeMachine run];
}
\end{minted}
\end{listing}

libclang cannot parse incomplete code snippets because it doesn't know whether an identifier is a variable name or a class name. For the above snippet, libclang generated the following error message:

\begin{listing}
\caption{Error messages generated by libclang for snippet in listing \ref{lst:incomplete}}
\begin{verbatim}
input.m:7:5: error: use of undeclared identifier 'speed'
input.m:8:5: error: use of undeclared identifier 'TimeMachine'
input.m:8:18: error: use of undeclared identifier 'timeMachine'
input.m:8:34: error: use of undeclared identifier 'TimeMachine'
input.m:9:6: error: use of undeclared identifier 'timeMachine'
\end{verbatim}
\end{listing}

We use a loop to fix them one by one until there's no errors. For each error, we use the identifier to guess whether it's a class name or a variable name. If the identifier starts with a capital letter, we assume it's a class name, otherwise we assume it's a variable name.
% TODO: this implementation will be changed to support property access
As mentioned before, we included a special header file \texttt{BabelSwiftHeader.h}. For undefined variable names, we declare them in the header file with type \texttt{id}. \texttt{id} in Objective-C is similar to \texttt{void *} in C, represents a pointer to any type. For undefined class names, we add interfaces in the header file. It is obvious to see that we may make wrong guesses based on this approach, e.g. a programmer could name a variable \texttt{IPAddress}. To make sure all the identifiers are being declared correctly, if it failed to fix the error, we will make another opposite guess. After fixing all the errors, libclang would be able to generate the AST. The header file \texttt{BabelSwiftHeader.h} for listing \ref{lst:incomplete} is like:

\begin{listing}
\caption{The content of \texttt{BabelSwiftHeader.h} after fixing all the errors}
\begin{minted}{objc}
#define BABEL_SWIFT_SOME_TYPE id

@class __BABEL_SWIFT_WRAPPER_CLASS__;
@class TimeMachine;

@interface __BABEL_SWIFT_WRAPPER_CLASS__ : NSObject
@end

@interface TimeMachine : NSObject
@end

BABEL_SWIFT_SOME_TYPE speed;
\end{minted}
\end{listing}

% TODO: chained property access

\section{Generating Swift-specific Code}

Swift have a different set of data types than Objective-C. We use mappings to convert basic data types. Because it's allowed to use C types in Objective-C, we also have mappings to C types.

\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf Objective-C \cite{objcdatatypes}} & {\bf Swift \cite{swiftdatatypes}} & \specialcell{{\bf Size in 32/64-bit}\\{\bf runtime (bytes)}} \\
\hline
\texttt{char}       & \texttt{Int8}   & 1 / 1 \\
\texttt{BOOL}, \texttt{bool} & \texttt{Int8}   & 1 / 1 \\
\texttt{short}      & \texttt{Int16}  & 2 / 2 \\
\texttt{int}        & \texttt{Int32}  & 4 / 4 \\
\texttt{long}       & \texttt{Int}    & 4 / 8 \\
\texttt{long long}  & \texttt{Int64}  & 8 / 8 \\
\texttt{size\_t}    & \texttt{Int}    & 4 / 8 \\
\texttt{time\_t}    & \texttt{Int}    & 4 / 8 \\
\texttt{NSInteger}  & \texttt{Int}    & 4 / 8 \\
\texttt{NSUInteger} & \texttt{Int}    & 4 / 8 \\
\texttt{float}      & \texttt{Float}  & 4 / 4 \\
\texttt{double}     & \texttt{Double} & 8 / 8 \\
\hline
\end{tabular}
\end{center}
\caption{Mappings for basic data types}
\end{table}

% TODO: method renaming

% TODO: for loop

% TODO: others (++, selector)

\section{Improving libclang}

Although libclang provides a set of methods for accessing the AST, it's implementation is incomplete.

unexposed

information in cursor

% TODO: Using PCH for better performance

\section{Remaining Issues}

Comments are useful in source code. It would be good to keep the comments during the conversion. Currently, they are simply dropped due to the limitation of libclang. 

Another potential improvement is to support functions and classes in addition to code snippets.

\chapter{Alternative Designs}

In this chapter, we briefly discuss some alternative designs to implement the conversion tool. Instead of using libclang, we can also build the tool directly upon Clang (or with LibTooling), or write the parser from scratch.

Babel Swift is based on libclang. As noted before, libclang offers a convinient and stable API for accessing the AST generated by Clang. It also has an official Python binding, which is very useful for fast prototyping. However, libclang doesn't provide the full access over the AST. To implement a decent conversion tool, many new featured have to be added in libclang. Moreover, as a young addition to Clang, libclang doesn't have complete documentation.

Clang is the de facto standard Objective-C frontend today. Using a Clang-based approach (including libclang and LibTooling) could save a lot of effort on parsing the Objective-C code.

All the designs differ from the frontend. Once the code in source language is converted to AST, the implementations of the backend are almost the same.

\section{Building Directly Upon Clang}

Building the tool directly upon Clang gives you the full control over the AST. There are two major drawbacks: First, Clang itself was not designed as a library. Setting up Clang to use it as a library is extremely complex. Second, Clang is evolving rapidly. It doesn't promise a stable API. If the tool is building upon a certain version of Clang, there's a good chance that the code will broken with the next version. In addition, to build based on Clang, you have to write the code in C++.

\subsection{LibTooling}

LibTooling is a library for writing standalone tools based on Clang \cite{libtooling}. As noted before, Clang has a complex setup process. Instead, LibTooling offers a straightforward setup process. LibTooling is an ideal framework to develop tools based on Clang.

Despite the drawbacks (unstable API, cannot use languages other than C++), if the objective is to build a full-fledged conversion tool, LibTooling is a better choice than libclang because of its full control over the AST.

\section{Writing Own Parser}

Using the own parser provides the best flexibility over the implementation. The parser could be written by hand or generated by parser generators. The most obvious drawback is that there are a lot of effort to implement a complete parser. objc2swift \cite{objc2swift} is using this approach.

\chapter{Evaluation}

Evaluating a code conversion tool is difficult, because there are no obvious metrics for them. Typical metrics like performance are not important for code conversion tools. Instead, the most important qualities for code conversion tools are \emph{the variety of input source code it can handle}, \emph{the correctness of converted code}, and \emph{the quality of converted code}. This chapter attempts to evaluate these qualities in the following sections.

\section{The Variety of Input Source Code}

\section{The Correctness of Converted Code}

\section{The Quality of Converted Code}

\chapter{Conclusion}



%   BACK MATTER  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   References and appendices. Appendices come after the bibliography and
%   should be in the order that they are referred to in the text.
%
%   If you include figures, etc. in an appendix, be sure to use
%
%       \caption[]{...}
%
%   to make sure they are not listed in the List of Figures.
%

\backmatter%
	\addtoToC{Bibliography}
	\bibliographystyle{plain}
	\bibliography{references}

\begin{appendices} % optional
	\chapter{Code}
\end{appendices}
\end{document}
